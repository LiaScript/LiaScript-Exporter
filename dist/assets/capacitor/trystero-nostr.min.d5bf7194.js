var e=("undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{}).parcelRequire55a5;e.register("g9MJ9",(function(t,r){var n,o;n=t.exports,o=function(){return Et},Object.defineProperty(n,"joinRoom",{get:o,set:undefined,enumerable:!0,configurable:!0});var a,i,s,c,f,l,d,u,h,y,g,p,m,w,v,b,E=e("dM3DM"),x=e("aQXMn"),A=Object.freeze({__proto__:null,default:{}});const S=BigInt(0),P=BigInt(1),I=BigInt(2),k=BigInt(3),B=BigInt(8),T=Object.freeze({a:S,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:P,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")}),H=(e,t)=>(e+t/I)/t,R={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(e){const{n:t}=T,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-P*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),a=r,i=BigInt("0x100000000000000000000000000000000"),s=H(a*e,t),c=H(-n*e,t);let f=re(e-s*r-c*o,t),l=re(-s*n-c*a,t);const d=f>i,u=l>i;if(d&&(f=t-f),u&&(l=t-l),f>i||l>i)throw Error("splitScalarEndo: Endomorphism failed, k="+e);return{k1neg:d,k1:f,k2neg:u,k2:l}}},U=32;function C(e){const{a:t,b:r}=T,n=re(e*e),o=re(n*e);return re(o+t*e+r)}const D=T.a===S;class z extends Error{constructor(e){super(e)}}function O(e){if(!(e instanceof $))throw new TypeError("JacobianPoint expected")}class ${static fromAffine(e){if(!(e instanceof _))throw new TypeError("JacobianPoint#fromAffine: expected Point");return e.equals(_.ZERO)?$.ZERO:new $(e.x,e.y,P)}static toAffineBatch(e){const t=function(e,t=T.P){const r=Array(e.length),n=oe(e.reduce(((e,n,o)=>n===S?e:(r[o]=e,re(e*n,t))),P),t);return e.reduceRight(((e,n,o)=>n===S?e:(r[o]=re(e*r[o],t),re(e*n,t))),n),r}(e.map((e=>e.z)));return e.map(((e,r)=>e.toAffine(t[r])))}static normalizeZ(e){return $.toAffineBatch(e).map($.fromAffine)}equals(e){O(e);const{x:t,y:r,z:n}=this,{x:o,y:a,z:i}=e,s=re(n*n),c=re(i*i),f=re(t*c),l=re(o*s),d=re(re(r*i)*c),u=re(re(a*n)*s);return f===l&&d===u}negate(){return new $(this.x,re(-this.y),this.z)}double(){const{x:e,y:t,z:r}=this,n=re(e*e),o=re(t*t),a=re(o*o),i=e+o,s=re(I*(re(i*i)-n-a)),c=re(k*n),f=re(c*c),l=re(f-I*s),d=re(c*(s-l)-B*a),u=re(I*t*r);return new $(l,d,u)}add(e){O(e);const{x:t,y:r,z:n}=this,{x:o,y:a,z:i}=e;if(o===S||a===S)return this;if(t===S||r===S)return e;const s=re(n*n),c=re(i*i),f=re(t*c),l=re(o*s),d=re(re(r*i)*c),u=re(re(a*n)*s),h=re(l-f),y=re(u-d);if(h===S)return y===S?this.double():$.ZERO;const g=re(h*h),p=re(h*g),m=re(f*g),w=re(y*y-p-I*m),v=re(y*(m-w)-d*p),b=re(n*i*h);return new $(w,v,b)}subtract(e){return this.add(e.negate())}multiplyUnsafe(e){const t=$.ZERO;if("bigint"==typeof e&&e===S)return t;let r=te(e);if(r===P)return this;if(!D){let e=t,n=this;for(;r>S;)r&P&&(e=e.add(n)),n=n.double(),r>>=P;return e}let{k1neg:n,k1:o,k2neg:a,k2:i}=R.splitScalar(r),s=t,c=t,f=this;for(;o>S||i>S;)o&P&&(s=s.add(f)),i&P&&(c=c.add(f)),f=f.double(),o>>=P,i>>=P;return n&&(s=s.negate()),a&&(c=c.negate()),c=new $(re(c.x*R.beta),c.y,c.z),s.add(c)}precomputeWindow(e){const t=D?128/e+1:256/e+1,r=[];let n=this,o=n;for(let a=0;a<t;a++){o=n,r.push(o);for(let t=1;t<2**(e-1);t++)o=o.add(n),r.push(o);n=o.double()}return r}wNAF(e,t){!t&&this.equals($.BASE)&&(t=_.BASE);const r=t&&t._WINDOW_SIZE||1;if(256%r)throw Error("Point#wNAF: Invalid precomputation window, must be power of 2");let n=t&&L.get(t);n||(n=this.precomputeWindow(r),t&&1!==r&&(n=$.normalizeZ(n),L.set(t,n)));let o=$.ZERO,a=$.BASE;const i=1+(D?128/r:256/r),s=2**(r-1),c=BigInt(2**r-1),f=2**r,l=BigInt(r);for(let t=0;t<i;t++){const r=t*s;let i=Number(e&c);e>>=l,i>s&&(i-=f,e+=P);const d=r,u=r+Math.abs(i)-1,h=t%2!=0,y=i<0;0===i?a=a.add(N(h,n[d])):o=o.add(N(y,n[u]))}return{p:o,f:a}}multiply(e,t){let r,n,o=te(e);if(D){const{k1neg:e,k1:a,k2neg:i,k2:s}=R.splitScalar(o);let{p:c,f:f}=this.wNAF(a,t),{p:l,f:d}=this.wNAF(s,t);c=N(e,c),l=N(i,l),l=new $(re(l.x*R.beta),l.y,l.z),r=c.add(l),n=f.add(d)}else{const{p:e,f:a}=this.wNAF(o,t);r=e,n=a}return $.normalizeZ([r,n])[0]}toAffine(e){const{x:t,y:r,z:n}=this,o=this.equals($.ZERO);null==e&&(e=o?B:oe(n));const a=e,i=re(a*a),s=re(i*a),c=re(t*i),f=re(r*s),l=re(n*a);if(o)return _.ZERO;if(l!==P)throw Error("invZ was invalid");return new _(c,f)}constructor(e,t,r){this.x=e,this.y=t,this.z=r}}function N(e,t){const r=t.negate();return e?r:t}$.BASE=new $(T.Gx,T.Gy,P),$.ZERO=new $(S,P,S);const L=new WeakMap;class _{_setWindowSize(e){this._WINDOW_SIZE=e,L.delete(this)}hasEvenY(){return this.y%I===S}static fromCompressedHex(e){const t=32===e.length,r=Q(t?e:e.subarray(1));if(!ce(r))throw Error("Point is not on curve");let n=function(e){const{P:t}=T,r=BigInt(6),n=BigInt(11),o=BigInt(22),a=BigInt(23),i=BigInt(44),s=BigInt(88),c=e*e*e%t,f=c*c*e%t,l=ne(f,k)*f%t,d=ne(l,k)*f%t,u=ne(d,I)*c%t,h=ne(u,n)*u%t,y=ne(h,o)*h%t,g=ne(y,i)*y%t,p=ne(g,s)*g%t,m=ne(p,i)*y%t,w=ne(m,k)*f%t,v=ne(w,a)*h%t,b=ne(v,r)*c%t,E=ne(b,I);if(E*E%t!==e)throw Error("Cannot find square root");return E}(C(r));const o=(n&P)===P;t?o&&(n=re(-n)):!(1&~e[0])!==o&&(n=re(-n));const a=new _(r,n);return a.assertValidity(),a}static fromUncompressedHex(e){const t=Q(e.subarray(1,33)),r=Q(e.subarray(33,65)),n=new _(t,r);return n.assertValidity(),n}static fromHex(e){const t=ee(e),r=t.length,n=t[0];if(32===r)return this.fromCompressedHex(t);if(33===r&&(2===n||3===n))return this.fromCompressedHex(t);if(65===r&&4===n)return this.fromUncompressedHex(t);throw Error("Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not "+r)}static fromPrivateKey(e){return _.BASE.multiply(fe(e))}static fromSignature(e,t,r){const{r:n,s:o}=function(e){if(e instanceof M)return e.assertValidity(),e;try{return M.fromDER(e)}catch(t){return M.fromCompact(e)}}(t);if(![0,1,2,3].includes(r))throw Error("Cannot recover: invalid recovery bit");const a=function(e,t=!1){const r=function(e){const t=8*e.length-256,r=Q(e);return t>0?r>>BigInt(t):r}(e);if(t)return r;const{n:n}=T;return r>=n?r-n:r}(ee(e)),{n:i}=T,s=2===r||3===r?n+i:n,c=oe(s,i),f=re(-a*c,i),l=re(o*c,i),d=1&r?"03":"02",u=_.fromHex(d+J(s)),h=_.BASE.multiplyAndAddUnsafe(u,f,l);if(!h)throw Error("Cannot recover signature: point at infinify");return h.assertValidity(),h}toRawBytes(e=!1){return Y(this.toHex(e))}toHex(e=!1){const t=J(this.x);return e?`${this.hasEvenY()?"02":"03"}${t}`:`04${t}${J(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const e="Point is not on elliptic curve",{x:t,y:r}=this;if(!ce(t)||!ce(r))throw Error(e);const n=re(r*r);if(re(n-C(t))!==S)throw Error(e)}equals(e){return this.x===e.x&&this.y===e.y}negate(){return new _(this.x,re(-this.y))}double(){return $.fromAffine(this).double().toAffine()}add(e){return $.fromAffine(this).add($.fromAffine(e)).toAffine()}subtract(e){return this.add(e.negate())}multiply(e){return $.fromAffine(this).multiply(e,this).toAffine()}multiplyAndAddUnsafe(e,t,r){const n=$.fromAffine(this),o=t===S||t===P||this!==_.BASE?n.multiplyUnsafe(t):n.multiply(t),a=$.fromAffine(e).multiplyUnsafe(r),i=o.add(a);return i.equals($.ZERO)?void 0:i.toAffine()}constructor(e,t){this.x=e,this.y=t}}function Z(e){return Number.parseInt(e[0],16)>=8?"00"+e:e}function j(e){if(e.length<2||2!==e[0])throw Error("Invalid signature integer tag: "+K(e));const t=e[1],r=e.subarray(2,t+2);if(!t||r.length!==t)throw Error("Invalid signature integer: wrong length");if(0===r[0]&&r[1]<=127)throw Error("Invalid signature integer: trailing length");return{data:Q(r),left:e.subarray(t+2)}}_.BASE=new _(T.Gx,T.Gy),_.ZERO=new _(S,S);class M{static fromCompact(e){const t=e instanceof Uint8Array,r="Signature.fromCompact";if("string"!=typeof e&&!t)throw new TypeError(r+": Expected string or Uint8Array");const n=t?K(e):e;if(128!==n.length)throw Error(r+": Expected 64-byte hex");return new M(F(n.slice(0,64)),F(n.slice(64,128)))}static fromDER(e){const t=e instanceof Uint8Array;if("string"!=typeof e&&!t)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r:r,s:n}=function(e){if(e.length<2||48!=e[0])throw Error("Invalid signature tag: "+K(e));if(e[1]!==e.length-2)throw Error("Invalid signature: incorrect length");const{data:t,left:r}=j(e.subarray(2)),{data:n,left:o}=j(r);if(o.length)throw Error("Invalid signature: left bytes after parsing: "+K(o));return{r:t,s:n}}(t?e:Y(e));return new M(r,n)}static fromHex(e){return this.fromDER(e)}assertValidity(){const{r:e,s:t}=this;if(!se(e))throw Error("Invalid Signature: r must be 0 < r < n");if(!se(t))throw Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const e=T.n>>P;return this.s>e}normalizeS(){return this.hasHighS()?new M(this.r,re(-this.s,T.n)):this}toDERRawBytes(){return Y(this.toDERHex())}toDERHex(){const e=Z(X(this.s)),t=Z(X(this.r)),r=e.length/2,n=t.length/2,o=X(r),a=X(n);return`30${X(n+r+4)}02${a}${t}02${o}${e}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return Y(this.toCompactHex())}toCompactHex(){return J(this.r)+J(this.s)}constructor(e,t){this.r=e,this.s=t,this.assertValidity()}}function V(...e){if(!e.every((e=>e instanceof Uint8Array)))throw Error("Uint8Array list expected");if(1===e.length)return e[0];const t=e.reduce(((e,t)=>e+t.length),0),r=new Uint8Array(t);for(let t=0,n=0;t<e.length;t++){const o=e[t];r.set(o,n),n+=o.length}return r}const q=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function K(e){if(!(e instanceof Uint8Array))throw Error("Expected Uint8Array");let t="";for(let r=0;r<e.length;r++)t+=q[e[r]];return t}const W=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function J(e){if("bigint"!=typeof e)throw Error("Expected bigint");if(!(S<=e&&e<W))throw Error("Expected number 0 <= n < 2^256");return e.toString(16).padStart(64,"0")}function G(e){const t=Y(J(e));if(32!==t.length)throw Error("Error: expected 32 bytes");return t}function X(e){const t=e.toString(16);return 1&t.length?"0"+t:t}function F(e){if("string"!=typeof e)throw new TypeError("hexToNumber: expected string, got "+typeof e);return BigInt("0x"+e)}function Y(e){if("string"!=typeof e)throw new TypeError("hexToBytes: expected string, got "+typeof e);if(e.length%2)throw Error("hexToBytes: received invalid unpadded hex"+e.length);const t=new Uint8Array(e.length/2);for(let r=0;r<t.length;r++){const n=2*r,o=e.slice(n,n+2),a=Number.parseInt(o,16);if(Number.isNaN(a)||a<0)throw Error("Invalid byte sequence");t[r]=a}return t}function Q(e){return F(K(e))}function ee(e){return e instanceof Uint8Array?Uint8Array.from(e):Y(e)}function te(e){if("number"==typeof e&&Number.isSafeInteger(e)&&e>0)return BigInt(e);if("bigint"==typeof e&&se(e))return e;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function re(e,t=T.P){const r=e%t;return r>=S?r:t+r}function ne(e,t){const{P:r}=T;let n=e;for(;t-- >S;)n*=n,n%=r;return n}function oe(e,t=T.P){if(e===S||t<=S)throw Error(`invert: expected positive integers, got n=${e} mod=${t}`);let r=re(e,t),n=t,o=S,a=P;for(;r!==S;){const e=n%r,t=o-a*(n/r);n=r,r=e,o=a,a=t}if(n!==P)throw Error("invert: does not exist");return re(o,t)}let ae,ie;function se(e){return S<e&&e<T.n}function ce(e){return S<e&&e<T.P}function fe(e){let t;if("bigint"==typeof e)t=e;else if("number"==typeof e&&Number.isSafeInteger(e)&&e>0)t=BigInt(e);else if("string"==typeof e){if(64!==e.length)throw Error("Expected 32 bytes of private key");t=F(e)}else{if(!(e instanceof Uint8Array))throw new TypeError("Expected valid private key");if(e.length!==U)throw Error("Expected 32 bytes of private key");t=Q(e)}if(!se(t))throw Error("Expected private key: 0 < key < n");return t}function le(e){return e instanceof _?(e.assertValidity(),e):_.fromHex(e)}function de(e){return re(Q(e),T.n)}class ue{static fromHex(e){const t=ee(e);if(64!==t.length)throw new TypeError("SchnorrSignature.fromHex: expected 64 bytes, not "+t.length);const r=Q(t.subarray(0,32)),n=Q(t.subarray(32,64));return new ue(r,n)}assertValidity(){const{r:e,s:t}=this;if(!ce(e)||!se(t))throw Error("Invalid signature")}toHex(){return J(this.r)+J(this.s)}toRawBytes(){return Y(this.toHex())}constructor(e,t){this.r=e,this.s=t,this.assertValidity()}}class he{getScalar(e){const t=_.fromPrivateKey(e),r=t.hasEvenY()?e:T.n-e;return{point:t,scalar:r,x:t.toRawX()}}initNonce(e,t){return G(e^Q(t))}finalizeNonce(e){const t=re(Q(e),T.n);if(t===S)throw Error("sign: Creation of signature failed. k is zero");const{point:r,x:n,scalar:o}=this.getScalar(t);return{R:r,rx:n,k:o}}finalizeSig(e,t,r,n){return new ue(e.x,re(t+r*n,T.n)).toRawBytes()}error(){throw Error("sign: Invalid signature produced")}async calc(){const{m:e,d:t,px:r,rand:n}=this,o=Ae.taggedHash,a=this.initNonce(t,await o(Ee.aux,n)),{R:i,rx:s,k:c}=this.finalizeNonce(await o(Ee.nonce,a,r,e)),f=de(await o(Ee.challenge,s,r,e)),l=this.finalizeSig(i,c,f,t);return await pe(l,e,r)||this.error(),l}calcSync(){const{m:e,d:t,px:r,rand:n}=this,o=Ae.taggedHashSync,a=this.initNonce(t,o(Ee.aux,n)),{R:i,rx:s,k:c}=this.finalizeNonce(o(Ee.nonce,a,r,e)),f=de(o(Ee.challenge,s,r,e)),l=this.finalizeSig(i,c,f,t);return me(l,e,r)||this.error(),l}constructor(e,t,r=Ae.randomBytes()){if(null==e)throw new TypeError(`sign: Expected valid message, not "${e}"`);this.m=ee(e);const{x:n,scalar:o}=this.getScalar(fe(t));if(this.px=n,this.d=o,this.rand=ee(r),32!==this.rand.length)throw new TypeError("sign: Expected 32 bytes of aux randomness")}}function ye(e,t,r){const n=e instanceof ue,o=n?e:ue.fromHex(e);return n&&o.assertValidity(),(0,x.default)((0,E.default)({},o),{m:ee(t),P:le(r)})}function ge(e,t,r,n){const o=_.BASE.multiplyAndAddUnsafe(t,fe(r),re(-n,T.n));return!(!o||!o.hasEvenY()||o.x!==e)}async function pe(e,t,r){try{const{r:n,s:o,m:a,P:i}=ye(e,t,r),s=de(await Ae.taggedHash(Ee.challenge,G(n),i.toRawX(),a));return ge(n,i,o,s)}catch(e){return!1}}function me(e,t,r){try{const{r:n,s:o,m:a,P:i}=ye(e,t,r),s=de(Ae.taggedHashSync(Ee.challenge,G(n),i.toRawX(),a));return ge(n,i,o,s)}catch(e){if(e instanceof z)throw e;return!1}}const we=e=>_.fromPrivateKey(e).toRawX(),ve=async(e,t,r)=>new he(e,t,r).calc();_.BASE._setWindowSize(8);const be={node:A,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},Ee={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"},xe={},Ae={bytesToHex:K,hexToBytes:Y,concatBytes:V,mod:re,invert:oe,isValidPrivateKey(e){try{return fe(e),!0}catch(e){return!1}},_bigintTo32Bytes:G,_normalizePrivateKey:fe,hashToPrivateKey(e){if((e=ee(e)).length<40||e.length>1024)throw Error("Expected valid bytes of private key as per FIPS 186");return G(re(Q(e),T.n-P)+P)},randomBytes(e=32){if(be.web)return be.web.getRandomValues(new Uint8Array(e));if(be.node){const{randomBytes:t}=be.node;return Uint8Array.from(t(e))}throw Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>Ae.hashToPrivateKey(Ae.randomBytes(40)),precompute(e=8,t=_.BASE){const r=t===_.BASE?t:new _(t.x,t.y);return r._setWindowSize(e),r.multiply(k),r},async sha256(...e){if(be.web){const t=await be.web.subtle.digest("SHA-256",V(...e));return new Uint8Array(t)}if(be.node){const{createHash:t}=be.node,r=t("sha256");return e.forEach((e=>r.update(e))),Uint8Array.from(r.digest())}throw Error("The environment doesn't have sha256 function")},async hmacSha256(e,...t){if(be.web){const r=await be.web.subtle.importKey("raw",e,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),n=V(...t),o=await be.web.subtle.sign("HMAC",r,n);return new Uint8Array(o)}if(be.node){const{createHmac:r}=be.node,n=r("sha256",e);return t.forEach((e=>n.update(e))),Uint8Array.from(n.digest())}throw Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,async taggedHash(e,...t){let r=xe[e];if(void 0===r){const t=await Ae.sha256(Uint8Array.from(e,(e=>e.charCodeAt(0))));r=V(t,t),xe[e]=r}return Ae.sha256(r,...t)},taggedHashSync(e,...t){if("function"!=typeof ae)throw new z("sha256Sync is undefined, you need to set it");let r=xe[e];if(void 0===r){const t=ae(Uint8Array.from(e,(e=>e.charCodeAt(0))));r=V(t,t),xe[e]=r}return ae(r,...t)},_JacobianPoint:$};Object.defineProperties(Ae,{sha256Sync:{configurable:!1,get:()=>ae,set(e){ae||(ae=e)}},hmacSha256Sync:{configurable:!1,get:()=>ie,set(e){ie||(ie=e)}}});const{floor:Se,random:Pe,sin:Ie}=Math,ke="Trystero",Be=(e,t)=>Array(e).fill().map(t),Te=e=>Be(e,(()=>"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"[Se(62*Pe())])).join(""),He=Te(20),Re=Promise.all.bind(Promise),Ue="undefined"!=typeof window,{entries:Ce,fromEntries:De,keys:ze}=Object,Oe=()=>{},$e=e=>Error(`${ke}: ${e}`),Ne=new TextEncoder,Le=new TextDecoder,_e=e=>Ne.encode(e),Ze=e=>Le.decode(e),je=e=>e.reduce(((e,t)=>e+t.toString(16).padStart(2,"0")),""),Me=(...e)=>e.join("@"),Ve=JSON.stringify,qe=JSON.parse,Ke=(e,t=Number.MAX_SAFE_INTEGER)=>e.split("").reduce(((e,t)=>e+t.charCodeAt(0)),0)%t,We={},Je="AES-GCM",Ge={},Xe=async e=>Ge[e]||(Ge[e]=Array.from(new Uint8Array(await crypto.subtle.digest("SHA-1",_e(e)))).map((e=>e.toString(36))).join("")),Fe=async(e,t)=>{const r=crypto.getRandomValues(new Uint8Array(16));var n;return r.join(",")+"$"+(n=await crypto.subtle.encrypt({name:Je,iv:r},await e,_e(t)),btoa(String.fromCharCode.apply(null,new Uint8Array(n))))},Ye=async(e,t)=>{const[r,n]=t.split("$");return Ze(await crypto.subtle.decrypt({name:Je,iv:new Uint8Array(r.split(","))},await e,(e=>{const t=atob(e);return new Uint8Array(t.length).map(((e,r)=>t.charCodeAt(r))).buffer})(n)))},Qe="icegatheringstatechange",et="offer";var tt=(e,{rtcConfig:t,rtcPolyfill:r,turnConfig:n})=>{const o=new(r||RTCPeerConnection)((0,E.default)({iceServers:rt.concat(n||[])},t)),a={};let i=!1,s=!1,c=null;const f=e=>{e.binaryType="arraybuffer",e.bufferedAmountLowThreshold=65535,e.onmessage=e=>{var t;return null===(t=a.data)||void 0===t?void 0:t.call(a,e.data)},e.onopen=()=>{var e;return null===(e=a.connect)||void 0===e?void 0:e.call(a)},e.onclose=()=>{var e;return null===(e=a.close)||void 0===e?void 0:e.call(a)},e.onerror=e=>{var t;return null===(t=a.error)||void 0===t?void 0:t.call(a,e)}},l=e=>Promise.race([new Promise((t=>{const r=()=>{"complete"===e.iceGatheringState&&(e.removeEventListener(Qe,r),t())};e.addEventListener(Qe,r),r()})),new Promise((e=>setTimeout(e,5e3)))]).then((()=>({type:e.localDescription.type,sdp:e.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")})));return e?(c=o.createDataChannel("data"),f(c)):o.ondatachannel=({channel:e})=>{c=e,f(e)},o.onnegotiationneeded=async()=>{try{var e;i=!0,await o.setLocalDescription();const t=await l(o);null===(e=a.signal)||void 0===e||e.call(a,t)}catch(e){var t;null===(t=a.error)||void 0===t||t.call(a,e)}finally{i=!1}},o.onconnectionstatechange=()=>{var e;["disconnected","failed","closed"].includes(o.connectionState)&&(null===(e=a.close)||void 0===e||e.call(a))},o.ontrack=e=>{var t,r;null===(t=a.track)||void 0===t||t.call(a,e.track,e.streams[0]),null===(r=a.stream)||void 0===r||r.call(a,e.streams[0])},o.onremovestream=e=>{var t;return null===(t=a.stream)||void 0===t?void 0:t.call(a,e.stream)},e&&(o.canTrickleIceCandidates||o.onnegotiationneeded()),{created:Date.now(),connection:o,get channel(){return c},get isDead(){return"closed"===o.connectionState},async signal(t){var r;if("open"!==(null==c?void 0:c.readyState)||(null===(r=t.sdp)||void 0===r?void 0:r.includes("a=rtpmap")))try{if(t.type===et){var n;if(i||"stable"!==o.signalingState&&!s){if(e)return;await Re([o.setLocalDescription({type:"rollback"}),o.setRemoteDescription(t)])}else await o.setRemoteDescription(t);await o.setLocalDescription();const r=await l(o);return null===(n=a.signal)||void 0===n||n.call(a,r),r}if("answer"===t.type){s=!0;try{await o.setRemoteDescription(t)}finally{s=!1}}}catch(e){var f;null===(f=a.error)||void 0===f||f.call(a,e)}},sendData:e=>c.send(e),destroy(){null==c||c.close(),o.close(),i=!1,s=!1},setHandlers:e=>Object.assign(a,e),offerPromise:e?new Promise((e=>a.signal=t=>{t.type===et&&e(t)})):Promise.resolve(),addStream:e=>e.getTracks().forEach((t=>o.addTrack(t,e))),removeStream:e=>o.getSenders().filter((t=>e.getTracks().includes(t.track))).forEach((e=>o.removeTrack(e))),addTrack:(e,t)=>o.addTrack(e,t),removeTrack(e){const t=o.getSenders().find((t=>t.track===e));t&&o.removeTrack(t)},replaceTrack(e,t){const r=o.getSenders().find((t=>t.track===e));if(r)return r.replaceTrack(t)}}};const rt=[...Be(3,((e,t)=>`stun:stun${t||""}.l.google.com:19302`)),"stun:stun.cloudflare.com:3478"].map((e=>({urls:e}))),nt=Object.getPrototypeOf(Uint8Array),ot=16369,at=255,it="bufferedamountlow",st=e=>"@_"+e;var ct;const ft={},lt="EVENT",dt=Ae.randomPrivateKey(),ut=je(we(dt)),ht={},yt={},gt={},pt=()=>Math.floor(Date.now()/1e3),mt=e=>null!==(ct=(a=gt)[i=e])&&void 0!==ct?ct:a[i]=Ke(e,1e4)+2e4,wt=async(e,t)=>{const r={kind:mt(e),content:t,pubkey:ut,created_at:pt(),tags:[["x",e]]},n=je(new Uint8Array(await crypto.subtle.digest("SHA-256",_e(Ve([0,r.pubkey,r.created_at,r.kind,r.tags,r.content])))));return Ve([lt,(0,x.default)((0,E.default)({},r),{id:n,sig:je(await ve(n,dt))})])},vt=(e,t)=>(ht[e]=t,Ve(["REQ",e,{kinds:[mt(t)],since:pt(),"#x":[t]}])),bt=e=>(delete ht[e],Ve(["CLOSE",e])),Et=(({init:e,subscribe:t,announce:r})=>{const n={};let o,a,i,v=!1;return(b,A,S)=>{var P;const{appId:I}=b;if(null===(P=n[I])||void 0===P?void 0:P[A])return n[I][A];const k={},B={},T=Me(ke,I,A),H=Xe(T),R=Xe(Me(T,He)),U=(async(e,t,r)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},_e(`${e}:${t}:${r}`)),{name:Je},!1,["encrypt","decrypt"]))(b.password||"",I,A),C=e=>async t=>({type:t.type,sdp:await e(U,t.sdp)}),D=C(Ye),z=C(Fe),O=()=>tt(!0,b),$=(e,t,r)=>{var n;B[t]?B[t]!==e&&e.destroy():(B[t]=e,V(e,t),null===(n=k[t])||void 0===n||n.forEach(((e,t)=>{t!==r&&e.destroy()})),delete k[t])},N=(e,t)=>{B[t]===e&&delete B[t]},L=e=>(a.push(...Be(e,O)),Re(a.splice(0,e).map((e=>e.offerPromise.then(z).then((t=>({peer:e,offer:t}))))))),_=(e,t)=>null==S?void 0:S({error:`incorrect password (${b.password}) when decrypting ${t}`,appId:I,peerId:e,roomId:A});if(!b)throw $e("requires a config map as the first argument");if(!I&&!b.firebaseApp)throw $e("config map is missing appId field");if(!A)throw $e("roomId argument required");if(!v){const t=e(b);a=Be(20,O),o=Array.isArray(t)?t:[t],v=!0,i=setInterval((()=>a=a.filter((e=>{const t=Date.now()-e.created<57333;return t||e.destroy(),t}))),59052.99)}const Z=o.map((()=>5333)),j=[],M=o.map((async(e,r)=>t(await e,await H,await R,(e=>async(t,r,n)=>{const[o,a]=await Re([H,R]);if(t!==o&&t!==a)return;const{peerId:i,offer:f,answer:l,peer:d}="string"==typeof r?qe(r):r;if(i!==He&&!B[i])if(!i||f||l){if(f){var u;if((null===(u=k[i])||void 0===u?void 0:u[e])&&He>i)return;const t=tt(!1,b);let r;t.setHandlers({connect:()=>$(t,i,e),close:()=>N(t,i)});try{r=await D(f)}catch(e){return void _(i,"offer")}if(t.isDead)return;const[o,a]=await Re([Xe(Me(T,i)),t.signal(r)]);n(o,Ve({peerId:He,answer:await z(a)}))}else if(l){let t;try{t=await D(l)}catch(e){return void _(i,"answer")}if(d)d.setHandlers({connect:()=>$(d,i,e),close:()=>N(d,i)}),d.signal(t);else{var h;const r=null===(h=k[i])||void 0===h?void 0:h[e];r&&!r.isDead&&r.signal(t)}}}else{var y;if(null===(y=k[i])||void 0===y?void 0:y[e])return;const[[{peer:t,offer:r}],o]=await Re([L(1),Xe(Me(T,i))]);(s=k)[c=i]||(s[c]=[]),k[i][e]=t,setTimeout((()=>((e,t)=>{var r;if(B[e])return;const n=null===(r=k[e])||void 0===r?void 0:r[t];n&&(delete k[e][t],n.destroy())})(i,e)),.9*Z[e]),t.setHandlers({connect:()=>$(t,i,e),close:()=>N(t,i)}),n(o,Ve({peerId:He,offer:r}))}})(r),L)));Re([H,R]).then((([e,t])=>{const n=async(o,a)=>{const i=await r(o,e,t);"number"==typeof i&&(Z[a]=i),j[a]=setTimeout((()=>n(o,a)),Z[a])};M.forEach((async(e,t)=>{await e,n(await o[t],t)}))}));let V=Oe;return(f=n)[l=I]||(f[l]={}),n[I][A]=((e,t,r)=>{const n={},o={},a={},i={},s={},c={},f={},l={onPeerJoin:Oe,onPeerLeave:Oe,onPeerStream:Oe,onPeerTrack:Oe},v=(e,t)=>(e?Array.isArray(e)?e:[e]:ze(n)).flatMap((e=>{const r=n[e];return r?t(e,r):(console.warn(`${ke}: no peer with id ${e} found`),[])})),b=e=>{n[e]&&(delete n[e],delete i[e],delete s[e],l.onPeerLeave(e),t(e))},A=e=>{if(o[e])return a[e];if(!e)throw $e("action type argument is required");const t=_e(e);if(t.byteLength>12)throw $e(`action type string "${e}" (${t.byteLength}b) exceeds byte limit (12). Hint: choose a shorter name.`);const r=new Uint8Array(12);r.set(t);let i=0;return o[e]={onComplete:Oe,onProgress:Oe,setOnComplete:t=>o[e]=(0,x.default)((0,E.default)({},o[e]),{onComplete:t}),setOnProgress:t=>o[e]=(0,x.default)((0,E.default)({},o[e]),{onProgress:t}),async send(e,t,o,a){if(o&&"object"!=typeof o)throw $e("action meta argument must be an object");const s=typeof e;if("undefined"===s)throw $e("action data cannot be undefined");const c="string"!==s,f=e instanceof Blob,l=f||e instanceof ArrayBuffer||e instanceof nt;if(o&&!l)throw $e("action meta argument can only be used with binary data");const d=l?new Uint8Array(f?await e.arrayBuffer():e):_e(c?Ve(e):e),u=o?_e(Ve(o)):null,h=Math.ceil(d.byteLength/ot)+(o?1:0)||1,y=Be(h,((e,t)=>{const n=t===h-1,a=o&&0===t,s=new Uint8Array(15+(a?u.byteLength:n?d.byteLength-ot*(h-(o?2:1)):ot));return s.set(r),s.set([i],12),s.set([n|a<<1|l<<2|c<<3],13),s.set([Math.round((t+1)/h*at)],14),s.set(o?a?u:d.subarray((t-1)*ot,t*ot):d.subarray(t*ot,(t+1)*ot),15),s}));return i=i+1&at,Re(v(t,(async(e,t)=>{const{channel:r}=t;let i=0;for(;i<h;){const s=y[i];if(r.bufferedAmount>r.bufferedAmountLowThreshold&&await new Promise((e=>{const t=()=>{r.removeEventListener(it,t),e()};r.addEventListener(it,t)})),!n[e])break;t.sendData(s),i++,null==a||a(s[14]/at,e,o)}})))}},(d=a)[u=e]||(d[u]=[o[e].send,o[e].setOnComplete,o[e].setOnProgress])},S=(e,t)=>{const r=new Uint8Array(t),n=Ze(r.subarray(0,12)).replaceAll("\0",""),[a]=r.subarray(12,13),[s]=r.subarray(13,14),[c]=r.subarray(14,15),f=r.subarray(15),l=!!(1&s),d=!!(2&s),u=!!(4&s),v=!!(8&s);if(!o[n])return void console.warn(`${ke}: received message with unregistered type (${n})`);(h=i)[y=e]||(h[y]={}),(g=i[e])[p=n]||(g[p]={});const b=(m=i[e][n])[w=a]||(m[w]={chunks:[]});if(d?b.meta=qe(Ze(f)):b.chunks.push(f),o[n].onProgress(c/at,e,b.meta),!l)return;const E=new Uint8Array(b.chunks.reduce(((e,t)=>e+t.byteLength),0));if(b.chunks.reduce(((e,t)=>(E.set(t,e),e+t.byteLength)),0),delete i[e][n][a],u)o[n].onComplete(E,e,b.meta);else{const t=Ze(E);o[n].onComplete(v?qe(t):t,e)}},P=async()=>{await O(""),await new Promise((e=>setTimeout(e,99))),Ce(n).forEach((([e,t])=>{t.destroy(),delete n[e]})),r()},[I,k]=A(st("ping")),[B,T]=A(st("pong")),[H,R]=A(st("signal")),[U,C]=A(st("stream")),[D,z]=A(st("track")),[O,$]=A(st("leave"));return V=(e,t)=>{var r;n[t]||(n[t]=e,e.setHandlers({data:e=>S(t,e),stream(e){l.onPeerStream(e,t,c[t]),delete c[t]},track(e,r){l.onPeerTrack(e,r,t,f[t]),delete f[t]},signal:e=>H(e,t),close:()=>b(t),error(e){console.error(e),b(t)}}),l.onPeerJoin(t),null===(r=e.drainEarlyData)||void 0===r||r.call(e,(e=>S(t,e))))},k(((e,t)=>B("",t))),T(((e,t)=>{var r;null===(r=s[t])||void 0===r||r.call(s),delete s[t]})),R(((e,t)=>{var r;return null===(r=n[t])||void 0===r?void 0:r.signal(e)})),C(((e,t)=>c[t]=e)),z(((e,t)=>f[t]=e)),$(((e,t)=>b(t))),Ue&&addEventListener("beforeunload",P),{makeAction:A,leave:P,async ping(e){if(!e)throw $e("ping() must be called with target peer ID");const t=Date.now();return I("",e),await new Promise((t=>s[e]=t)),Date.now()-t},getPeers:()=>De(Ce(n).map((([e,t])=>[e,t.connection]))),addStream:(e,t,r)=>v(t,(async(t,n)=>{r&&await U(r,t),n.addStream(e)})),removeStream:(e,t)=>v(t,((t,r)=>r.removeStream(e))),addTrack:(e,t,r,n)=>v(r,(async(r,o)=>{n&&await D(n,r),o.addTrack(e,t)})),removeTrack:(e,t)=>v(t,((t,r)=>r.removeTrack(e))),replaceTrack:(e,t,r,n)=>v(r,(async(r,o)=>{n&&await D(n,r),o.replaceTrack(e,t)})),onPeerJoin:e=>l.onPeerJoin=e,onPeerLeave:e=>l.onPeerLeave=e,onPeerStream:e=>l.onPeerStream=e,onPeerTrack:e=>l.onPeerTrack=e}})(0,(e=>delete B[e]),(()=>{delete n[I][A],j.forEach(clearTimeout),M.forEach((async e=>(await e)())),clearInterval(i)}))}})({init:e=>((e,t,r)=>(e.relayUrls||((e,t)=>{const r=[...e],n=()=>{const e=1e4*Ie(t++);return e-Se(e)};let o=r.length;for(;o;){const e=Se(n()*o--);[r[o],r[e]]=[r[e],r[o]]}return r})(t,Ke(e.appId))).slice(0,e.relayUrls?e.relayUrls.length:e.relayRedundancy||5))(e,xt).map((e=>{const t=((e,t)=>{const r={},n=()=>{const o=new WebSocket(e);o.onclose=()=>{var t;null!==(t=(v=We)[b=e])&&void 0!==t||(v[b]=3333),setTimeout(n,We[e]),We[e]*=2},o.onmessage=e=>t(e.data),r.socket=o,r.url=o.url,r.ready=new Promise((t=>o.onopen=()=>{t(r),We[e]=3333})),r.send=e=>{1===o.readyState&&o.send(e)}};return n(),r})(e,(e=>{var r;const[n,o,a,i]=qe(e);if(n===lt)null===(r=yt[o])||void 0===r||r.call(yt,ht[o],a.content);else{const e=`${ke}: relay failure from ${t.url} - `;"NOTICE"===n?console.warn(e+o):"OK"!==n||a||console.warn(e+i)}}));return ft[e]=t,t.ready})),subscribe(e,t,r,n){const o=Te(64),a=Te(64);return yt[o]=yt[a]=(t,r)=>n(t,r,(async(t,r)=>e.send(await wt(t,r)))),e.send(vt(o,t)),e.send(vt(a,r)),()=>{e.send(bt(o)),e.send(bt(a)),delete yt[o],delete yt[a]}},announce:async(e,t)=>e.send(await wt(t,Ve({peerId:He})))});const xt=["eu.purplerelay.com","ftp.halifax.rwth-aachen.de/nostr","multiplexer.huszonegy.world","nostr.cool110.xyz","nostr.data.haus","nostr.grooveix.com","nostr.huszonegy.world","nostr.mom","nostr.sathoarder.com","nostr.vulpem.com","relay.fountain.fm","relay.nostraddress.com","relay.nostromo.social","relay.snort.social","relay.verified-nostr.com","yabu.me/v2"].map((e=>"wss://"+e))}));
